\subsection{Fase 1}

    \par Nesta fase foi realizado todo o processo base do fluxo de trabalho, tendo sido escolhida a aplicação de teste (aplicação Todo App, utilizada durante a aula).

    \par No workflow (ver Source Code~\ref{code:workflow_fase_1}) definiu-se que quando for realizado um push para o branch \emph{main}, o fluxo de trabalho fica ativo, sendo depois criada a imagem da app e posteriormente é feito o push da imagem para o Azure Container Registry (ACR), para alem disso, as credenciais de acesso ao ACR foram colocadas como segredos do repositório.

    \begin{code}
        \inputminted[linenos,tabsize=1,breaklines,lastline=21]{yaml}{../.github/workflows/project-workflow-fase-1.yml}
        \caption{Workflow utilizado na Fase 1}
        \label{code:workflow_fase_1}
    \end{code}

    \par Relativamente ao Dockerfile, o codigo foi utilizado de um dockerfile fornecido numa das aulas da unidade curricular, tendo sido adicionada a linha 5 e tendo sido feito algumas alterações (ver Source Code~\ref{code:dockerfile}).

    \begin{code}
        \inputminted[linenos,tabsize=1,breaklines]{dockerfile}{../todo_app/app/Dockerfile}
        \caption{DockerFile da app}
        \label{code:dockerfile}
    \end{code}

    \par Relativamente ao fluxo de trabalho foram realizados os seguintes passos:
    \begin{enumerate}
        \item Criou-se um grupo de recursos:

        \begin{minted}[tabsize=1,breaklines]{shell}
az group create --name ProjetoSDGrupo3 --location eastus
        \end{minted}

        \item Criou-se um registo de contentores (Azure Container Registry) no Azure:

        \begin{minted}[tabsize=1,breaklines]{shell}
az acr create --resource-group ProjetoSDGrupo3 --name projetosdgrupo3 --sku Standard
        \end{minted}

        \item Ativou-se \emph{admin} no ACR:

        \begin{minted}[tabsize=1,breaklines]{shell}
az acr update -n projetosdgrupo3 --admin-enabled true
        \end{minted}

        \item Criou-se um Cluster do AKS:

        \begin{minted}[tabsize=1,breaklines]{shell}
az aks create --resource-group ProjetoSDGrupo3 --name projetosdgrupo3AKSCluster --node-count 2 --generate-ssh-keys
        \end{minted}

        \item Obteve-se as credenciais do Cluster AKS:

        \begin{minted}[tabsize=1,breaklines]{shell}
az aks get-credentials --resource-group ProjetoSDGrupo3 --name projetosdgrupo3AKSCluster
        \end{minted}

        \item Conectou-se o Cluster AKS ao ACR:

        \begin{minted}[tabsize=1,breaklines]{shell}
az aks update --attach-acr projetosdgrupo3 --name projetosdgrupo3AKSCluster --resource-group ProjetoSDGrupo3
        \end{minted}


        \item Obteve-se as credenciais de acesso ao ACR:

        \begin{minted}[tabsize=1,breaklines]{shell}
az acr show -n projetosdgrupo3 --query loginServer -o tsv
az acr credential show -n projetosdgrupo3 --query username -o tsv
az acr credential show -n projetosdgrupo3 --query passwords[0].value -o tsv
        \end{minted}

        \item Colocou-se as credencias do ACR como segredos no repositório.
        \item Fez-se um push para o \emph{main} de forma a ativar o workflow.
        \item No Azure Cli, criamos um ficheiro \emph{app.yaml}, e copiamos o código presente no ficheiro \emph{app.yaml} (ver Source Code~\ref{code:app_yaml}).

        \begin{minted}[tabsize=1,breaklines]{shell}
nano app.yaml
        \end{minted}

        \item Criou-se o cluster a partir do ficheiro \emph{app.yaml}.

        \begin{minted}[tabsize=1,breaklines]{shell}
kubectl apply -f app.yaml
        \end{minted}

        \item Obteve-se o endereço IP externo para abrir a app no browser.

        \begin{minted}[tabsize=1,breaklines]{shell}
kubectl get service todo-app --watch
        \end{minted}

    \end{enumerate}




\subsection{Fase 2}

    \par Nesta fase o procedimento realizado foi diferente do realizado na fase 1, não tendo sido usado o Azure Container Registry nem o Azure Kubernetes Service. Nesta fase utilizou-se o Github Actions e o DockerHub para o fluxo de trabalho e de integração continua.
    \par Para a criação do cluster local foram utilizados 2 raspberry pi's, sendo que um é o master e o outro é o worker/slave. Foram atribuidos 2 endereços IP, 1 para cada RPI (ver Tabela~\ref{table:IP_address_password_hostname_rpi})

    \begin{table}[h!]
        \centering

        \begin{tabular}{ c c c c }
            \hline
            \textbf{Role} & \textbf{IP Address} & \textbf{Password} & \textbf{Hostname} \\
            \hline
            Master & 10.2.15.156 & \emph{Node3\_2} & node32 \\
            % \hline
            Worker/Slave & 10.2.15.155 & \emph{Node3\_1} & node31 \\
            \hline
        \end{tabular}

        \caption{Endereços IP, Password e Hostname dos Raspberry Pi's.}

        \label{table:IP_address_password_hostname_rpi}
    \end{table}

    \par Para a configuração dos RPI, utilizou-se 2 cartões micro sd preparados anteriormente para possibilitar o acesso aos RPI's a partir de ssh, e para poder iniciar os RPI's a partir de uma pen USB.
    \par Para a configuração das pens USB, a serem usadas para iniciar cada um dos RPI's, foram realizados os seguintes passos:

    \begin{enumerate}
        \item Gravou-se o sistema operativo (Raspbian OS Lite 32-bits).
        \item Criou-se um ficheiro ssh no diretório boot do sistema.
        \item Editou-se o ficheiro 'cmdline.txt' adicionando o seguinte separado por espaços:

        \begin{itemize}
            \item No ficheiro do worker/slave:

            \begin{itemize}
                \item cgroup\_enable \( = \) cpuset
                \item cgroup\_memory \( = \) 1
                \item cgroup\_enable \( = \) memory
                \item ip \( = \) 10.2.15.155
            \end{itemize}

            \item No ficheiro do master:

            \begin{itemize}
                \item cgroup\_enable \( = \) cpuset
                \item cgroup\_memory \( = \) 1
                \item cgroup\_enable \( = \) memory
                \item ip \( = \) 10.2.15.156
            \end{itemize}

        \end{itemize}

        \item Ligou-se cada pen USB ao respetivo RPI em substituição do cartão SD.
        \item Alterou-se as configurações do RPI (Ativar SSH; mudar a password, alterar o hostname. Ver Tabela \ref{table:IP_address_password_hostname_rpi}).
        \item Editou-se os ficheiros '/etc/dhcpcd.conf' e 'cmdline.txt', retirando comentarios e adicionando o IP, e apagando o IP de cada ficheiro respetivamente.
        \item Trocou-se a framework \textbf{nftables} pela \textbf{iptables}. Realizando depois um reboot dos RPI's.
        \item De seguida instalou-se e configurou-se o K3s com os seguintes comandos:

        \begin{enumerate}
            \item No Master:

            \begin{enumerate}
                \item \mintinline{shell}{K3S_KUBECONFIG_MODE="644"}
                \item \mintinline{shell}{curl -sfL https://get.k3s.io | sh -}
                \item Testou-se se a instalação ocorreu sem erros usando:\\
                    \mintinline{shell}{sudo kubectl get nodes}
                \item Copiou-se o Token do Master:\\
                    \mintinline{shell}{sudo cat /var/lib/rancher/k3s/server/node-token}
            \end{enumerate}

            \item No Worker/Slave:

            \begin{enumerate}
                \item Conectou-se o Worker/Slave com o Master, usando o IP do Master e o Token copiado:

                \begin{minted}[breaklines,tabsize=1]{shell}
curl -sfL http://get.k3s.io | K3S_URL=https://IP_DO_MASTER:6443 K3S_TOKEN=TOKEN_OBTIDO_PREVIAMENTE sh -
                \end{minted}

            \end{enumerate}
        \end{enumerate}

        \item Testou-se no Master se a conexão com o Worker/Slave funciona:\\
            \mintinline{shell}{sudo kubectl get nodes}

    \end{enumerate}

    \par Relativamente à criação da imagem, criou-se um workflow do github relativo à esta fase, para que quando seja realizado um push para o branch \emph{main}, seja criada a imagem e colocada no DockerHub (ver Source Code~\ref{code:buid_image}).

        \begin{code}
            \inputminted[linenos,breaklines,tabsize=1,firstline=19,lastline=24]{yaml}{../.github/workflows/project-workflow-fase-2.yml}

            \captionof{listing}{Image build}
            \label{code:buid_image}
        \end{code}

    \par Após a imagem ter sido colocada no DockerHub, e os RPI's terem a configuração do K3s concluída e a funcionar, utilizou-se o ficheiro \emph{app.yaml} (ver Source Code~\ref{code:app_yaml}) para criar o cluster.
